#+TITLE: postMessage Study

* send 

** source code from =send= from file =JKMessageQueue.cpp=
  File =JKMessageQueue.cpp=:

  #+BEGIN_SRC C
RET JKMessageQueue< C_MESSAGE_QUEUE >::send(MSG_TYPE type, const void* const data, const unsigned int size, unsigned char priority)
{
	RET ret = RET_ERROR;
	int sys_ret = -1;
	struct msgbuf buf;

	if (C_MAX_DATA_LEN < size)
	{
		JK_LOGE(1, "size over(%d)\n", size);
		return RET_ERROR_INVALID_ARG;
	}

	if((MSG_TYPE_DATA == type) && (0 == priority))
	{
		JK_LOGE(1, "invalid priority(%d)\n", priority);
		return RET_ERROR_INVALID_ARG;
	}

	if(false == this->isOpened())
	{
		JK_LOGE(1, "not opened\n");
		return ret;
	}

	struct mq_attr attr;
	while(1)
	{
		mq_getattr(this->mq_, &attr);
		if(attr.mq_curmsgs >= attr.mq_maxmsg)
		{
			JK_LOGE(1, "que full (%s) %d/%d\n", this->name_, attr.mq_curmsgs, attr.mq_maxmsg);
			return RET_ERROR_QUE_FULL;
		}
		else
		{
			break;
		}
	}

	priority = 255 - priority;

	buf.type = type;
	jk_memcpy(buf.data, C_MAX_DATA_LEN, data, size);

	while ((sys_ret = mq_send(this->mq_, reinterpret_cast<char*>(&buf), sizeof(long)+size, priority)) == -1 && errno == EINTR)
	{
		continue;       /* Restart if interrupted by handler */
	}
	if(-1 == sys_ret)
	{
		JK_LOGE(1, "error : errno[%d : %s]\n", errno, strerror(errno));
	}
	else
	{
		ret = RET_SUCCESS;
	}

	return ret;
}
  #+END_SRC

  =struct msgbuf buf=

  =struct mq_attr attr=

  =mq_send=

  is used in this function.

  It utilize the POSIX Message Queue to send message,

  to study POSIX message queue, refer to book 

  =The Linux Programming Interface=  

  and chapter 52: =POSIX Message Queues=

** postMessage class diagram

  #+BEGIN_SRC plantuml :file img/postmessage-class-derivation.png
  class JKIMessageSender {	
	  +virtual bool postMessage(JKIPCMessageCore& msg, sint responseTimeout = -1) = 0;
  }

  class JKMessageSenderImpl {
	  +virtual bool postMessage(JKIPCMessageCore& msg, sint responseTimeout = -1);
	  -bool postMessageImpl(JKIPCMessageCore& msg, jkapp_def::ApplicationId senderAppId, JKMsgQ::Sender* pSender, sint timeout);	
  }

  JKIMessageSender <|-- JKMessageSenderImpl : derived from this interface
  note top of JKMessageSenderImpl : implementation of postMessage 

  class InfotainmentSender {
	  #virtual bool postMessage(JKIPCMessageCore& msg, sint responseTimeout = -1){mpSender->postMessage}
	  -JKIMessageSender* mpSender;
  }

  class CameraMessageSender {
	+CameraMessageSender(JKIMessageSender* pSender);
  }

  InfotainmentSender <|-- CameraMessageSender 
  note on link #red : mpSender is assigned to parents

  JKIMessageSender <.. InfotainmentSender : mpSender using this class
  
  #+END_SRC

  #+RESULTS:
  [[file:img/postmessage-class-derivation.png]]

  Note there is =JKIMessageSender* mpSender= in =Infotainment= class as private member,

  in constructor =InfotainmentSender=, =pSender= is assigned to =InfotainmentSender= =JKIMessageSender* mpSender=


  #+BEGIN_SRC C
InfotainmentSender::InfotainmentSender(JKIMessageSender* pSender)
: mpSender(pSender)
  #+END_SRC

  in Constructor =CameraMessageSender=, calling =InfortaimentSender= constructor and assign pSender to
  =InfotainmentSender= private member =JKIMessageSender* mpSender=

  #+BEGIN_SRC C
CameraMessageSender::CameraMessageSender(JKIMessageSender* pSender)
: InfotainmentSender(pSender)
  #+END_SRC

  #+RESULTS:
  [[file:img/postmessage-class-derivation.png]]


** postMessage obtain mpSenderBase

#+BEGIN_SRC plantuml :file img/mpSenderbase.png
  @startuml
  title mpSenderBase obtain
  participant "GuiMessenger" as D
  participant "JKAppBase" as C
  participant "IPCMessageController" as B
  participant "MasterMessenger" as A
  alt GuiMessaenger call constructor and call new IPCMessageController for calling constructor
  D->B: mpMsgController(new IPCMessageController(jkapp_def::APPLICATIONID_GUI))
  activate B
  deactivate B
  else JKAppBase call constructor, and call new IPCMessageController
  C -> B : mpMsgController = new IPCMessageController(appid)
  activate B
  end
  deactivate B
  B->B: mpSender(new JKMessageSenderImpl(mpWorker)) in constructor
  activate B
  deactivate B
  B->B: initialize
  activate B
  deactivate B
  note over B
  mpMessenger->distributeSender(mpSender);
  end note
  B->A: distributeSender(JKIMessageSender *pSender)
  activate A
  A->A : mpSenderBase = pSender
  deactivate A
  @enduml
#+END_SRC

#+RESULTS:
[[file:img/mpSenderbase.png]]


** postMessage postMessage sequence diagram, mpSenderBase obtain as above diagram
  #+BEGIN_SRC plantuml :file img/postmessage.png
  title postMessage
    actor "starting point" as J
    participant "AppMain" as I
    participant "MasterMessenger derived from JKMessengerCore" as H
    participant "MasterController" as G
    participant "FunctionController" as F
    participant "MessageSenderFactory" as E
    participant "CameraMessageSender" as D
    participant "InfotainmentSender" as C
    participant "JKMessageQueue" as B
    participant "JKMessageSenderImpl" as A
    J->I: enterApp
    note over I
    mpReceiver->initializeComplete(&ev)
    end note
    I->H: initializeComplete(JKEvent* pQuitEvent)
    note over H #red
    mpController->instantiate(mpSenderbase);
    mpSender comming from where????, as above sequence diagram
    end note	
    H->G: instantiate(JKIMessageSender * pSender)
    G->F: createFunctions(JKIMessageSender* pSender)
    note over F
    InfotainmentSender* pInfoSender = mpSenderFactory->createSender(pSender, p->getFunctionPackage());	
    end note	
    F->E : createSender(JKIMessageSender *pSender, info_def::FunctionPackageType funcPackage)
    E->D : new CameraMessageSender(pSender)
    note over E
    CameraMessageSender::CameraMessageSender(JKIMessageSender* pSender)
	    : InfotainmentSender(pSender)

    pSender used for construction of InfotainmentSender class	
    end note	
    D->C: postMessage(JKIPCMessageCore &msg, sint responseTimeout)
    note over C
	    JKIMessageSender* mpSender
	    return mpSender->postMessage(msg, responseTimeout)

    This is calling the postMessage from JKIMessage implemented from JKMessagSenderImpl	
    end note

    C->A : postMessage(JKIPCMessageCore &msg, sint responseTimeout)
    A->A: postMessageImpl(msg, senderAppId, JKMsgQ::Sender *pSender, sint timeout)
    note over A
    pSender->send(msg.getBuff(), msg.getSize(), msg.getPriority())	;
    end note	
    A->B : send(MSG_TYPE type, const void* const data, const unsigned int size, unsigned char priority)
  #+END_SRC

  #+RESULTS:
  [[file:img/postmessage.png]]

* receive

  File =JKMessageQueue.cpp=:

  #+BEGIN_SRC C
int JKMessageQueue< C_MESSAGE_QUEUE >::receive(MSG_TYPE &type, void* data, const unsigned int dataLen)
{
	int ret = -1;
	unsigned int pri = 0;

	if ((0 == data) || (0 >= dataLen))
	{
		JK_LOGE(1, "invalid args\n");
		return ret;
	}

	if(false == this->isOpened())
	{
		JK_LOGE(1, "not opened\n");
		return ret;
	}

	#ifdef PLATFORM_LINUX_PC

	while ((ret = mq_receive(this->mq_, reinterpret_cast<char*>(&this->rcvBuf_), 8192, &pri)) == -1 && errno == EINTR)
	#else
	while ((ret = mq_receive(this->mq_, reinterpret_cast<char*>(&this->rcvBuf_), C_MAX_DATA_LEN, &pri)) == -1 && errno == EINTR)
	#endif
	{
		continue;       /* Restart if interrupted by handler */
	}
	if(-1 == ret)
	{
		JK_LOGE(1, "error : errno[%d : %s]\n", errno, strerror(errno));
	}
	else
	{
		type = static_cast<MSG_TYPE>(this->rcvBuf_.type);
		jk_memcpy(data, dataLen, this->rcvBuf_.data, ret);
	}

	return ret;
}
  #+END_SRC
